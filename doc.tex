\documentclass [ titlepage ]{article}

\title{final project}
\author{Erfan Tajik}
\date{\today}

\begin{document}

\maketitle

\tableofcontents
\newpage

\section{Git and Github}
\subsection{ Repository Initialization and Commits}
i make new repo in github, then i go to actions section and add new action and copy action file from milli repo and paste it,
then i clone the project on my system, create new doc.tex file and push it

\subsection{GitHub Actions for LaTeX Compilation}
To create a lightweight tag (just a pointer to a commit), use: \newline
\textdollar git tag [tagname] \newline 
To push a single tag to GitHub, use: \newline
\textdollar git push origin [tagname] \newline
by the action that we add in last section when we push in github with a new tag, github automaticaly compile our file and release it.


\section{Exploration Tasks}
\subsection{ Vim Advanced Features}
1. Macros - Vim allows you to record and replay sequences of commands as macros. This allows you to automate repetitive tasks. To record a macro, press q followed by a register (a-z), perform your commands, then press q again to stop recording. To replay the macro, press @ followed by the register. \newline \newline
2. Vimscript - Vim has its own scripting language called Vimscript that allows you to customize and extend the editor. You can write Vimscripts to create custom commands, mappings, autocommands, and more. Vimscript files have a .vim extension and are loaded automatically on startup. \newline \newline
3. Splits and Tabs - Vim allows you to view and edit multiple files or views of the same file in a single session. You can split the window horizontally or vertically to show different split panes using :split or :vsplit. Within each split you can open a file. Vim also supports tabs, allowing you to open files or splits in separate tab pages accessed through :tabnew or :tabedit. You can navigate between splits and tabs to easily work across multiple files/views.

\subsection{Memory profiling}
\subsubsection{Memory Leak}
A memory leak occurs when memory is allocated dynamically but is not freed when it is no longer needed. This often happens when pointers to allocated memory are lost or overwritten before the memory is freed. Common causes in C include: \newline
- Forgetting to free memory that was previously allocated with malloc()/calloc()  /realloc(). Any memory not explicitly freed will remain allocated until the program exits. \newline
- Failing to free memory before overwriting a pointer that points to it. If the only pointer to a block of memory gets overwritten, that memory can no longer be accessed to free it. \newline
- Continuously allocating new memory without freeing old memory that is no longer needed. Over time this can cause the program to run out of available memory. \newline
- Freeing the same memory block twice. This can corrupt the heap memory management structures, making future allocations fail. \newline

\subsubsection{Memory profilers}
Valgrind is an extremely useful tool for detecting memory leaks and debugging other memory-related issues in programs written in languages like C and C++. Here are some key points about Valgrind: \newline
Purpose: Valgrind is designed to help find memory management and threading bugs, including memory leaks, in programs. It can detect issues that are difficult to uncover with traditional debugging.\newline
How it works: Valgrind instruments and monitors a program's execution to track how it uses memory. It inserts its own memory management code and checks for invalid operations like leaks. \newline
Detecting leaks: When a program is run through Valgrind, it will track memory allocations and identify leaks by detecting any memory blocks that are allocated but never freed before program termination. \newline
Other issues found: In addition to leaks, Valgrind can find uses of uninitialized memory, accesses of invalid memory, duplicate frees, memory overlap errors, and thread synchronization problems. \newline
Minimal overhead: A major advantage of Valgrind is that it imposes fairly low overhead on execution time compared to other memory debugging approaches. \newline
Usage: To use Valgrind, you run your program by executing the Valgrind tool with your program as the argument. It will analyze and report any issues as the program runs. \newline




\end{document}
